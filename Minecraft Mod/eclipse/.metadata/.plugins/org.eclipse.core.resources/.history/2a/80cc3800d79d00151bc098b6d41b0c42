package com.ThreeFoolsStudios.SpectralMod.Gui;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.ThreeFoolsStudios.SpectralMod.init.SpectralItems;

import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;

public class SpectralRecipes {

	private static final SpectralRecipes Gems = new SpectralRecipes();
	// This creates a HashMap whose Key is a specific, ordered List of Integers
	// If you want multiple outputs from one recipe, change the ItemStack to an ItemStack[]
	// (and of course adjust your TileEntity and Container code)
	private HashMap<List<Integer>, ItemStack> metaInscribingList = new HashMap<List<Integer>, ItemStack>();
	// Same as above except it gives us the experience for each crafting result
	private HashMap<List<Integer>, Float> metaExperience = new HashMap<List<Integer>, Float>();

	/**
	* Used to call methods addInscribing and getInscribingResult.
	*/
	public static final SpectralRecipes Gems() {
	return Gems;
	}

	/**
	* Adds all recipes to the HashMap
	*/
	private SpectralRecipes()
	{

	// This one only takes 2 Items to craft:
	this.addInscribing(Arrays.asList(SpectralItems.Arcane_Shard,SpectralItems.Arcane_Shard,SpectralItems.Arcane_Shard),new ItemStack(SpectralItems.Arcane_Gem), 0.3F);
	this.addInscribing(Arrays.asList(SpectralItems.Elemental_Shard,SpectralItems.Elemental_Shard,SpectralItems.Elemental_Shard),new ItemStack(SpectralItems.Elemental_Gem), 0.3F);
	this.addInscribing(Arrays.asList(SpectralItems.Necromantic_Shard,SpectralItems.Necromantic_Shard,SpectralItems.Necromantic_Shard),new ItemStack(SpectralItems.Necromantic_Gem), 0.3F);
	
	}

	/**
	* Adds an array of runes, the resulting scroll, and experience given
	*/
	public void addInscribing(List<Item> list, ItemStack gem, float experience)
	{
	// Check if recipe already exists and print conflict information:
	if (metaInscribingList.containsKey(list))
	{
	System.out.println("[WARNING] Conflicting recipe: " + list.toString() + " for " + metaInscribingList.get(list).toString());
	}
	else
	{
	// Add new recipe to the HashMap... wow, it looks so simple like this :)
	metaInscribingList.put(list, gem);
	metaExperience.put(Arrays.asList(gem.itemID, gem.getItemDamage()), experience);
	}
	}

	/**
	* Used to get the resulting ItemStack form a source inventory (fed to it by the contents of the slots in your container)
	* @param item The Source inventory from your custom furnace input slots
	* @return The result ItemStack (NOTE: if you want multiple outputs, change to ItemStack[] and adjust accordingly)
	*/
	public ItemStack getInscribingResult(ItemStack[] gems)
	{
	// count the recipe length so we can make the appropriate sized array
	int recipeLength = 0;
	for (int i = 0; i < gems.length && gems[i] != null && i < ForgeTileEntityContainer.InputSlots; ++i)
	{
	// +1 for metadata value of itemstack, add another +1 if you also need the itemID
	++recipeLength;
	}
	// make the array and fill it with the integer values from the passed in ItemStacks
	// Note that I'm only using the metadata value as all my runes have the same itemID
	Integer[] idIndex = new Integer[recipeLength];
	for (int i = 0; i < recipeLength; ++i) {
	// if you need itemID as well put this:
	// idIndex[i] = (Integer.valueOf(runes[i].itemID));
	// be sure to increment i before you do the metadata if you added an itemID
	idIndex[i] = (Integer.valueOf(gems[i].getItemDamage()));
	}
	// And use it as the key to get the correct result from the HashMap:
	return (ItemStack) metaInscribingList.get(Arrays.asList(idIndex));
	}

	/**
	* Grabs the amount of base experience for this item to give when pulled from the furnace slot.
	*/
	public float getExperience(ItemStack item)
	{
	if (item == null || item.getItem() == null)
	{
	return 0;
	}
	float ret = -1; // value returned by "item.getItem().getSmeltingExperience(item);" when item doesn't specify experience to give
	if (ret < 0 && metaExperience.containsKey(Arrays.asList(item.itemID, item.getItemDamage())))
	{
	ret = metaExperience.get(Arrays.asList(item.itemID, item.getItemDamage()));
	}

	return (ret < 0 ? 0 : ret);
	}

	public Map<List<Integer>, ItemStack> getMetaInscribingList()
	{
	return metaInscribingList;
	}
	
}
